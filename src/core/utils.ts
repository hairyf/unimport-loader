/* eslint-disable node/prefer-global/process */
import type { createUnimport, Import, InlinePreset } from 'unimport'
import type { LoaderContext } from 'webpack'

import type { LoaderOptions } from '../types'
import { writeFileSync } from 'node:fs'
import { join } from 'node:path'

import { toArray } from '@antfu/utils'
import { transform } from 'oxc-transform'

import { resolvePreset } from 'unimport'
import { detectIsJsxResource } from '../shared/helpers'

import { logger } from '../shared/logger'

/**
 * Flatten imports configuration into a flat array of Import objects
 */
export async function flattenImports(importsConfig: LoaderOptions['imports']): Promise<Import[]> {
  const promises = await Promise.all(toArray(importsConfig)
    .map(async (definition) => {
      if ('from' in definition && 'imports' in definition) {
        return await resolvePreset(definition as InlinePreset)
      }
      else if ('name' in definition && 'from' in definition) {
        // It's an Import object
        return [definition as Import]
      }
      else {
        const resolved: Import[] = []
        for (const mod of Object.keys(definition)) {
          for (const id of definition[mod]) {
            const meta = {
              from: mod,
            } as Import
            if (Array.isArray(id)) {
              meta.name = id[0]
              meta.as = id[1]
            }
            else {
              meta.name = id
              meta.as = id
            }
            resolved.push(meta)
          }
        }
        return resolved
      }
    }))

  return promises.flat()
}

/**
 * Prepare source code for import detection by transforming JSX/TSX if needed
 */
export async function prepareSourceCode(filePath: string, source: string): Promise<string> {
  const isJSX = detectIsJsxResource(filePath)
  if (!isJSX) {
    return source
  }

  const result = await transform(filePath, source, {
    lang: filePath.endsWith('.tsx') ? 'tsx' : 'jsx',
    jsx: { runtime: 'classic' },
    sourcemap: false,
  })
  return result.code
}

/**
 * Emit TypeScript declaration files for auto-imported symbols
 */
const emittedDts = new Set<string>()

export async function emitDts(
  unimport: ReturnType<typeof createUnimport>,
  options: LoaderOptions,
  loaderContext: LoaderContext<LoaderOptions>,
) {
  if (!options.dts) {
    return
  }

  const filename = options.dts === true ? 'auto-imports.d.ts' : String(options.dts)
  if (emittedDts.has(filename)) {
    return
  }

  const dts = await unimport.generateTypeDeclarations()
  const content = `${[
    '/* eslint-disable */',
    '/* prettier-ignore */',
    '// @ts-nocheck',
    '// noinspection JSUnusedGlobalSymbols',
    '// Generated by unimport-loader',
    '// biome-ignore lint: disable',
    dts,
  ].join('\n')}\n`

  if ('emitFile' in loaderContext && typeof loaderContext.emitFile === 'function') {
    loaderContext.emitFile(filename, content)
    logger.info(`Emitted type declarations to ${filename}`)
  }
  else {
    const filePath = join(process.cwd(), filename)
    try {
      writeFileSync(filePath, content, 'utf-8')
      logger.info(`Wrote type declarations to ${filePath}`)
    }
    catch (error) {
      logger.error(`Failed to write ${filePath}:`, error)
    }
  }
  emittedDts.add(filename)
}
